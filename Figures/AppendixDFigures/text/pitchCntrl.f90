REAL(ReKi), INTENT(IN )      :: DT                      ! Integration time step, sec.
REAL(ReKi), INTENT(IN )      :: ElecPwr                 ! Electrical power, watts.
REAL(ReKi), INTENT(IN )      :: GBRatio                 ! Gearbox ratio, (-).
REAL(ReKi), INTENT(IN )      :: HSS_Spd                 ! HSS speed, rad/s.
REAL(ReKi), INTENT(OUT)      :: BlPitchCom_out(NumBl)   ! Commanded blade pitch angles (demand pitch angles), rad.
REAL(ReKi), INTENT(IN )      :: TwrAccel                ! Tower Acceleration, m/s^2.
REAL(ReKi), INTENT(IN )      :: ZTime                   ! Current simulation time, sec.

CHARACTER(1024), INTENT(IN ) :: DirRoot                 ! The name of the root file including the full path to the current working directory.  This may be useful if you want this routine to write a permanent record of what it does to be stored with the simulation results: the results should be stored in a file whose name (including path) is generated by appending any suitable extension to DirRoot.

 ! Local Variables:

REAL(ReKi)                      :: ElapTime      ! Elapsed time since the last call to the controller, sec.
REAL(ReKi)                      :: GK            ! Current value of the gain correction factor, used in the gain scheduling law of the pitch controller, (-).
REAL(ReKi), SAVE                :: IntSpdErr     ! Current integral of speed error w.r.t. time, rad.
REAL(ReKi), SAVE                :: LastTimePC    ! Last time the pitch  controller was called, sec.
REAL(ReKi), PARAMETER           :: OnePlusEps = 1.0 + EPSILON(OnePlusEps) ! The number slighty greater than unity in single precision.
REAL(ReKi), PARAMETER           :: PC_DT = 0.00125     ! Communication interval for pitch  controller, sec.
REAL(ReKi), PARAMETER           :: PC_KI =       0.008068634  ! Integral gain for pitch controller at rated pitch (zero), (-).
REAL(ReKi), PARAMETER           :: PC_KK =       0.1099965    ! Pitch angle were the the derivative of the aerodynamic power w.r.t. pitch has increased by a factor of two relative to the derivative at rated pitch (zero), rad.
REAL(ReKi), PARAMETER           :: PC_KP =       0.01882681   ! Proportional gain for pitch controller at rated pitch (zero), sec.
REAL(ReKi), PARAMETER           :: PC_MaxPit =       1.570796     ! Maximum pitch setting in pitch controller, rad.
REAL(ReKi), PARAMETER           :: PC_MaxRat =       0.1396263    ! Maximum pitch  rate (in absolute value) in pitch  controller, rad/s.
REAL(ReKi), SAVE                :: PitCom (3)     ! Commanded pitch of each blade the last time the controller was called, rad.
REAL(ReKi)                      :: PitComI        ! Integral term of command pitch, rad.
REAL(ReKi)                      :: PitComP        ! Proportional term of command pitch, rad.
REAL(ReKi)                      :: PitComT        ! Total command pitch based on the sum of the proportional and integral terms, rad.
REAL(ReKi)                      :: PitRate(3)     ! Pitch rates of each blade based on the current pitch angles and current pitch command, rad/s.
REAL(ReKi)                      :: SpdErr         ! Current speed error, rad/s.
LOGICAL                   	    :: Initialize = .TRUE.  ! A status flag set by the simulation as follows: 0 if this is the first call, 1 for all subsequent time steps, -1 if this is the final call at the end of the simulation.
INTEGER(ReKi)                   :: K              ! Loops through blades.
INTEGER(ReKi)                   :: pitCoun = 1	  !Used for debug output

!=======================================================================
   !Initialize variables:
  
IF ( Initialize ) THEN  ! .TRUE. if we're on the first call to the subroutine
   WRITE(*,*)  'Running with pitch control programmed by Eric Anderson '// &
              'in subroutine PitchCntrl(), which can be found in UserSubs.f90 '
	Initialize = .FALSE.
   ! Initialize the SAVEd variables:
   PitCom     = BlPitch                         ! This will ensure that the variable speed controller picks the correct control region and the pitch controller pickes the correct gain on the first call. If pitchCtrl()is called before UsrVSCtrl() initializing it here will work, if not I need to do something else.
   GK         = 1.0/( 1.0 + PitCom(1)/PC_KK )   ! This will ensure that the pitch angle is unchanged if the initial SpdErr is zero
   IntSpdErr  = PitCom(1)/( GK*PC_KI )          ! This will ensure that the pitch angle is unchanged if the initial SpdErr is zero
   LastTimePC = ZTime - PC_DT                   ! This will ensure that the pitch  controller is called on the first pass 
ENDIF

!=======================================================================
   ! Pitch control:

   ! Compute the elapsed time since the last call to the controller:
ElapTime = ZTime - LastTimePC

   ! Only perform the control calculations if the elapsed time is greater than
   !   or equal to the communication interval of the pitch controller:
   ! NOTE: Time is scaled by OnePlusEps to ensure that the contoller is called
   !       at every time step when PC_DT = DT, even in the presence of
   !       numerical precision errors.

IF ( ( ZTime*OnePlusEps - LastTimePC ) >= PC_DT )  THEN

	CALL updateControlParameters( HSS_Spd, ZTime )
	
	IF ( EmergencyShutdown ) THEN
		PitComT = 3.1415926535/2
	ELSE
	   ! Compute the gain scheduling correction factor based on the previously
	   !   commanded pitch angle for blade 1:
		  GK = 1.0/( 1.0 + PitCom(1)/PC_KK )

	   ! Compute the current speed error and its integral w.r.t. time; 
		  SpdErr    = GenSpeedF - PC_RefSpd                                 ! Current speed error
		  IntSpdErr = IntSpdErr + SpdErr*ElapTime                           ! Current integral of speed error w.r.t. time
	  
		! saturate the integral term using the pitch angle limits:
		  IntSpdErr = MIN( MAX(IntSpdErr,PC_MinPit/(GK*PC_KI)), & 
		                  PC_MaxPit/( GK*PC_KI))    ! Saturate the integral term using the pitch angle limits, converted to integral speed error limits

		! Compute the pitch commands associated with the proportional and integral gains: 
		  PitComP   = GK*PC_KP*   SpdErr                                    ! Proportional term
		  PitComI   = GK*PC_KI*IntSpdErr                                    ! Integral term (saturated)


		! Superimpose the individual commands to get the total pitch command;
		  PitComT   = PitComP + PitComI                                     ! Overall command (unsaturated)
	  
	  
		!   saturate the overall command using the pitch angle limits:
		  PitComT   = MIN( MAX( PitComT, PC_MinPit ), PC_MaxPit )           ! Saturate the overall command using the pitch angle limits
	ENDIF

      DO K = 1,NumBl ! Loop through all blades
         PitRate(K) = ( PitComT - BlPitch(K) )/ElapTime                 ! Pitch rate of blade K (unsaturated)
         PitRate(K) = MIN( MAX( PitRate(K), -PC_MaxRat ), PC_MaxRat )   ! Saturate the pitch rate of blade K using its maximum absolute value
         PitCom (K) = BlPitch(K) + PitRate(K)*ElapTime                  ! Saturate the overall command of blade K using the pitch rate limit
      ENDDO          ! K - all blades

   ! Reset the value of LastTimePC to the current value:
      LastTimePC = ZTime
      
    IF ( controlDebug ) THEN
		WRITE(*,*)  'Time=',ZTime,'pitCount=',pitCount,'HSS_Spd=',HSS_Spd,&
    	          'GenSpeedF=',GenSpeedF,'PitCom=',PitCom(1),'PitComP= ',&
        	      PitComP,'PitComI= ',PitComI,'PitComT= ',PitComT
            	  pitCount=pitCount+1
 	ENDIF
      
ENDIF

BlPitchCom_out = PitCom                   ! Pass the most recent blade pitch command out of the subroutine
 
RETURN
END SUBROUTINE PitchCntrl